cationModeChangeHandler(evt){ \n    if (atomicState.paused) \n    { \n        return \n } \n    logging("$evt.name is now in $evt.value mode") \n\n    mainloop() \n } \ndef dimmersHandler(evt){ \n\n    if (atomicState.paused) \n    { \n        return \n } \n    if (location.mode in restrictedModes) \n    { \n        log.info "App paused due to modes restrictions (current mode: $location.mode | restricted Modes: ${restrictedModes?.join(", ")} trfh5"\n        return \n } \n    logging """\n$evt.device set to $evt.value \natomicState.lastDimValSetByApp = $atomicState.lastDimValSetByApp \natomicState.override=$atomicState.override """\n\n    atomicState.lastDimValSetByApp = atomicState.lastDimValSetByApp != null ? atomicState.lastDimValSetByApp : true\n\n    if (override && !atomicState.lastDimValSetByApp && !atomicState.override) \n    { \n        log.trace "USER OVERRIDE (will be canceled in 2 hours)"\n        atomicState.overrideTime = now() \n        atomicState.override = true\n } \n    if (atomicState.override) \n    { \n        atomicState.override = false\n        log.trace "END OF USER OVERRIDE DUE TO NEW USER NEW INPUT"\n } \n\n    //atomicState.lastDimValSetByApp = false // get ready for a new user input \n\n    //mainloop() // infinite feedback loop if called from here...\n}\ndef illuminanceHandler(evt){\n    if(atomicState.paused)\n    {\n        return\n    }\n    if(location.mode in restrictedModes)\n    {\n        log.info "App paused due to modes restrictions (current mode: $location.mode | restricted Modes: ${restrictedModes?.join(", ")} 2z6rg7"\n        return\n    }\n    descriptiontext("$evt.name is now $evt.value")\n\n    // learn max value if required\n    def currentSensor = switchSensor2 == null || sensor2 == null ? sensor : switchSensor2?.currentValue("switch") == "switchState" ? sensor2 : sensor \n    def illum = currentSensor.currentValue("illuminance")\n    def maxVal = atomicState.maxValue.toInteger()\n    if(idk && illum?.toInteger() > maxVal && !logarithm)\n    {\n        atomicState.maxValue = illum\n        logging("new maximum lux value registered as: $atomicState.maxValue")\n    }\n    else \n    {\n        logging "max value preset by user: ${maxValue}lux"\n        atomicState.maxValue = maxValue\n    }\n\n    mainloop()\n\n}\ndef motionHandler(evt){\n    if(atomicState.paused)\n    {\n        return\n    }\n    if(location.mode in restrictedModes)\n    {\n        log.info "App paused due to modes restrictions (current mode: $location.mode | restricted Modes: ${restrictedModes?.join(", ")}8erthj"\n        return\n    }\n\n    log.trace "MOTION EVT ----- $evt.device is $evt.value"\n\n    if(usemotion) \n    {\n        if(evt.value == "active")\n        {\n            atomicState.activeEvents = atomicState.activeEvents == null ? 0 : atomicState.activeEvents\n            atomicState.activeEvents += 1\n            atomicState.lastActiveEvent = now()\n\n            if(enablewarning) atomicState.timeCmd = now()\n            def dimVal = logarithm ? getDimValLog() : getDimVal()\n            setDimmers(["dimVal": dimVal]) // for faster exec\n        }\n        if(evt.value == "inactive") mainloop()\n    }\n}\ndef presenceHandler(evt){\n    log.info "$evt.device is $evt.value"\n    mainloop()\n}\ndef appButtonHandler(btn) {\n    logwarn "atomicState.paused = $atomicState.paused"\n\n    switch(btn) {\n        case "pause":atomicState.paused = !atomicState.paused\n        log.debug "atomicState.paused = $atomicState.paused"\n        appLabel()\n        break\n        case "update":\n        atomicState.paused = false\n        updated()\n        break\n        case "run":\n        atomicState.Tname = "button handler"\n        atomicState.T = now() \n        mainloop()\n        appLabel()\n        break\n\n    }\n}\n\ndef mainloop(){\n\n    def start = now()\n\n    if(enablelogging && now() - atomicState.enableLogging > 1800 * 60)\n    {\n        disablelogging()\n        log.debug "logging disabled"\n    }\n\n    if(location.mode in restrictedModes)\n    {\n        log.info "App paused due to modes restrictions (current mode: $location.mode | restricted Modes: ${restrictedModes?.join(", ")} 8rth4zj"\n        return\n    }\n    if(managePresence)\n    {\n        boolean presenceRestriction = presenceRestricted ? presenceRestricted.any{it -> it.currentValue("presence") == "present"}  : false\n        boolean absenceRestriction = absenceRestricted ? absenceRestricted.findAll{it.currentValue("presence") == "not present"}.size() == absenceRestricted.size() : false\n        if(presenceRestriction)\n        {\n            def list = presenceRestricted.findAll{it.currentValue("presence") == "present"}\n            def listOfPresence = list?.join(", ")\n\n            log.info "App is paused because $listOfPresence ${list.size() > 1 ? "are" : "is"} present"\n            atomicState.pausedByPresenceSensor = true\n            atomicState.paused = true\n        }\n        else if(absenceRestriction)\n        {\n            def listOfPresence = absenceRestricted?.join(", ")\n\n            log.info "App is paused because $listOfPresence ${list.size() > 1 ? "are" : "is"} NOT present"\n            atomicState.pausedByPresenceSensor = true\n            atomicState.paused = true\n        }\n        else if(atomicState.pausedByPresenceSensor)\n        {\n            atomicState.pausedByPresenceSensor = false\n            atomicState.paused = false\n        }\n        if(atomicState.paused)\n        {\n            atomicState.pauseTime = atomicState.pauseTime ? atomicState.pauseTime : now()\n            if(buttonPauseDelay && now() - atomicState.pauseTime > buttonPauseDelay)\n            {\n                atomicState.paused = false\n            }\n            return\n        }\n    }\n\n    atomicState.T = atomicState.T != null ? atomicState.T : now()\n    atomicState.T = atomicState.Tname == "end of main loop" ? atomicState.T = now() : atomicState.T // when called by schedule()\n    atomicState.Tname = atomicState.Tname == "end of main loop" ? atomicState.Tname = "schedule call" :  atomicState.Tname\n\n    atomicState.overrideTime = atomicState.overrideTime != null ? atomicState.overrideTime : now()\n\n    if(override)\n    {\n        if(atomicState.override && now() - atomicState.overrideTime < overrideDuration*60*60*1000)\n        {\n            log.trace("App paused for $overrideDuration ${overrideDuration>1 ? "hours":"hour"} due to user\'s manual input override")  \n            return\n        }\n        else if(atomicState.override && atomicState.overrideTime >= overrideDuration*60*60*1000)\n        {\n            atomicState.override = false\n            atomicState.lastDimValSetByApp = true // prevent false positive on next cycle\n            log.trace "END OF OVERRIDE, RESUMING NORMAL OPERATION"\n        }\n    }\n\n\n    boolean Active = stillActive()\n\n    boolean dimOff = dimmers.findAll{it.currentValue("switch") == "off"}.size() == dimmers.size() \n    boolean keepDimmersOff = false\n\n    logging("""\nnumber of dimmers that are off = ${dimmers.findAll{it.currentValue("switch") == "off"}.size()}\nnumber of dimmers that are set to 0 = ${dimmers.findAll{it.currentValue("level") == 0}.size()}\ndimmers.size() = ${dimmers.size()}\n""")\n\n    keepDimmersOff = usemotion ? dimOff && (otherApp || override) && !atomicState.turnedOffByNoMotionEvent : dimOff && (otherApp || override)\n\n    logging("""\nusemotion = $usemotion\nkeepDimmersOff = $keepDimmersOff\ndimOff = $dimOff\noutofmodes = $outofmodes\noverride = $override ${usemotion ? "" : "(Redundant when not using motion)"}\nActive = $Active ${usemotion ? "" : "but doesn\'t use motion"}\nlocation.mode = ${location.mode}\nrestrictedModes = $restrictedModes\n\n""")\n\n    if(Active && (!keepDimmersOff || atomicState.turnedOffByNoMotionEvent))\n    {\n        atomicState.turnedOffByNoMotionEvent = false\n        def dimVal = logarithm ? getDimValLog() : getDimVal()\n\n        atomicState.lastDimValSetByApp = true\n        runIn(10, resetLastDimBool) // get ready for a new user manual override input \n        //dimVal = dimVal == 0 ? 1 : dimVal // 0 can\'t seem to go through data parameter with runin / platform inteprets it as boolean "false" and throws MissingMethodExceptionNoStack\n        //dimVal = 10\n        //log.warn "dimVal = $dimVal"\n        //setDimmers(dimVal)\n        runIn(5, setDimmers, [data:[dimVal:dimVal]])\n\n        //switches?.on()\n        if(switches) logging "${switches} turned off"\n    }\n    else if(Active && keepDimmersOff)\n    {\n        def message = ""\n        if(override) message = "App in override mode for $overrideDuration ${overrideDuration > 1 ? "hours":"hour"} - or dimmers turned off by a different app or by user"\n        if(!override) message = "dimmers are off and managed by a different app, $app.label will resume when they\'re turned back on keepDimmersOff = $keepDimmersOff"\n        description message\n    }\n    else if(!Active)\n    {\n        descriptiontext "no motion..."\n        atomicState.turnedOffByNoMotionEvent = true\n        dimmers.off() \n        switches?.off()\n        if(switches) logging "${switches} turned off"\n    }\n\n    if(atomicState.turnedOffByNoMotionEvent)\n    {\n        log.trace "keepDimmersOff not set to true because atomicState.turnedOffByNoMotionEvent = true : turned off by no motion event, not user or other app input"\n    }\n\n    if(highLuxSwitch)\n    {\n        def illuminance = sensor.currentValue("illuminance").toInteger()\n        def maxVal = atomicState.maxValue != null ? atomicState.maxValue.toInteger() : maxValue.toInteger()\n        def NeedCurtainOff = onlyIfTempHigh ? highTempSensor.currentValue("temperature") >= tempThreshold && illuminance >= maxVal : illuminance >= maxVal\n\n\n        descriptiontext """*********\nmeasured illuminance = $illuminance\nmaxVal (for curtains) = $maxVal\n\n"""\n        atomicState.curtainsWereTurnedOff = atomicState.curtainsWereTurnedOff != null ? atomicState.curtainsWereTurnedOff : false\n\n        if(switchSensor2 && NeedCurtainOff && !atomicState.curtainsWereTurnedOff)\n        {\n            switchSensor2."${switchState}"()\n            atomicState.curtainsWereTurnedOff = true\n            logging "turning $switchSensor2 $switchState due to excess of illuminance"\n        }\n        else if(switchSensor2 && !NeedCurtainOff && toggleBack && atomicState.curtainsWereTurnedOff)\n        {\n            switchSensor2."${switchState == "off" ? "on" : "off"}"()\n            atomicState.curtainsWereTurnedOff = false\n            logging "turning $switchSensor2 ${switchState == "off" ? "on" : "off"} because illumiance is low again"\n        }\n\n    }\n\n    logwarn "mainloop duration: ${(now() - start)} millis"\n}\n\ndef resetLastDimBool(){\n    atomicState.lastDimValSetByApp = false\n}\ndef getDimVal(){\n    if(atomicState.paused)\n    {\n        return\n    }\n\n    boolean switchStateTrue = switchSensor2 ? switchSensor2?.currentValue("switch") == switchState : false\n    def currentSensor =  switchStateTrue ? sensor2 : sensor\n    def illum = currentSensor.currentValue("illuminance")\n\n    logging """\nLINEAR\n${switchSensor2 ? "switchSensor2 = $switchSensor2" : ""}\n${switchSensor2 ? "${switchSensor2?.currentValue("switch")}" : ""}\n${switchSensor2 ? "switchStateTrue = $switchStateTrue" : ""}\n${switchSensor2 ? "switchState boolean reference is: $switchState" : ""}\n\n\nilluminance sensor is: $currentSensor\nilluminance is: $illum lux\nmaxValue = ${maxValue ? "$maxValue (user defined value, no learning)" : "atomicState.maxValue = $atomicState.maxValue (learned value)"}\n"""\n    def maxIllum = idk && !logarithm ? atomicState.maxValue : maxValue  // if idk selected, then use last learned max value (atomicState.maxValue)\n\n\n    def y = null // value to find\n    def x = illum // current illuminance\n    def xa = maxIllum // maximum dimming value\n    def ya = 0      //coressponding dimming value for when illuminance = xa\n\n    def m = -0.1 // multiplier/slope \n\n    y = m*(x-xa)+ya // solving y-ya = m*(x-xa)\n    //logging "algebra found y = $y"\n    dimVal = y.toInteger()\n    dimVal = otherApp ? (dimVal < 1 ? dimVal = 1 : dimVal) : (dimVal < 0 ? dimVal = 0 : dimVal)\n    dimVal = dimVal > 100 ? 100 : dimVal // useless due to slope being -0.1 but just in case I forget about the slope\'s value function, I leave this line and its comment here\n\n    logging """illuminance: $illum, maximum illuminance: $maxIllum -|- ${maxValue ? "(user defined maxValue = $maxValue)" : ""}\n\nlinear dimming value result = ${dimVal} \n"""\n\n    return dimVal.toInteger()\n}\ndef getDimValLog(){ // logarithmic \n    if(atomicState.paused)\n    {\n        return\n    }\n    boolean switchStateTrue = switchSensor2 ? switchSensor2.currentValue("switch") == switchState : false\n    def currentSensor =  switchStateTrue ? sensor2 : sensor\n    def illum = currentSensor.currentValue("illuminance")\n\n\n    logging """\nLOGARITHMIC\n${switchSensor2 ? "switchSensor2 = $switchSensor2" : ""}\n${switchSensor2 ? "${switchSensor2?.currentValue("switch")}" : ""}\n${switchSensor2 ? "switchStateTrue = $switchStateTrue" : ""}\n${switchSensor2 ? "switchState boolean reference is: $switchState" : ""}\n\n\nilluminance sensor is: $currentSensor\nilluminance is: $illum lux \nNo max value in logarithmic mode..\n"""\n    def y = null // value to find\n    def x = illum != 0 ? illum : 1 // current illuminance // prevent "ava.lang.ArithmeticException: Division by zero "\n\n\n    def a = offset ? offset : 300\n    def b = sensitivity // this value is the overall sensitivity set by the user\n    def c = multiplier ? multiplier : 70 \n\n    y = (Math.log10(1/x)/Math.log10(b))*c+a\n    logging "log${b}(1/${x})*${c}+${a} -> $y"\n    dimVal = y.toInteger()\n    dimVal = otherApp ? (dimVal < 1 ? dimVal = 1 : dimVal) : (dimVal < 0 ? dimVal = 0 : dimVal)\n    dimVal = dimVal > 100 ? 100 : dimVal \n\n    logging "LOGARITHMIC dimming value = ${dimVal} (illuminance: $illum)"\n    return dimVal\n}\ndef setDimmers(val){   \n\n    val = val.dimVal\n    //val = val == "null" || val == null ? 0 : val\n    log.warn "setDimmers to $val"\n\n    if(atomicState.paused)\n    {\n        return\n    }\n\n    atomicState.lastDimValSetByApp = true\n\n    def i = 0\n    def s = dimmers.size()\n\n    if(modemgt)\n    {\n        if(location.mode in modes){\n\n            while(location.mode != modes[i]){i++}\n            def valMode = "dimValMode${i}" // set as max\n            def maxvalinthismode = settings.find{it.key == valMode}.value\n\n            if(val > maxvalinthismode)\n            {\n                logging("ADJUSTED WITH CURRENT MODE == > valMode = $valMode && maxvalinthismode = $maxvalinthismode")\n                val = maxvalinthismode\n            }\n        }\n    }\n\n    val = val < 0 ? 0 : (val > 100 ? 100 : val) // just a precaution\n    if(val == 0) \n    { \n        dimmers.off() // it seems some hue devices don\'t fully turn off when simply dimmed to 0, so turn them off\n    }\n    else\n    {\n        dimmers.on() // make sure it\'s on, in case some other dumb device drivers don\'t get that 0+1 != 0... \n    }\n    if(minimumValue && val < minimumValue) val = minimumValue\n    dimmers.setLevel(val)\n    logging("${dimmers.join(",")} set to $val ---")\n}\n\nboolean stillActive(){\n    logwarn "motion test start"\n    def start = now()\n\n    boolean result = true\n    int events = 0\n    boolean inTimeOutModes = modetimeout ? location.mode in timeoutModes : true\n    atomicState.activeEvents = now() - atomicState.lastActiveEvent > Dtime ? 0 : atomicState.activeEvents\n\n    if(modetimeout && !inTimeOutModes) // if use timeout modes and not in this mode, then ignore motion (keep lights on)\n    {\n        log.trace "Location is outside of timeout modes, ignoring motion events"\n        return result\n    }\n    if(usemotion)\n    {\n        def currentlyActive = motionSensors.findAll{it -> it.currentValue("motion") == "active"}\n        if(currentlyActive?.size() > 0) \n        {\n            log.trace "${currentlyActive.join(", ")} ${currentlyActive?.size() > 1 ? "are" : "is"} currently active"\n            return true\n        }\n\n        atomicState.activeEvents = atomicState.activeEvents == null ? 0 : atomicState.activeEvents\n        atomicState.lastActiveEvent = atomicState.lastActiveEvent == null ? now() : atomicState.lastActiveEvent\n\n        int timeOut = getTimeout()\n        long Dtime = timeOut * 60 * 1000 \n        events = 0\n        def period = new Date(now() - Dtime)\n\n        motionSensors.each { sensor ->\n            events += sensor.eventsSince(period, [max:200]).findAll{it.value == "active"}.size()\n        }\n\n        descriptiontext "atomicState.activeEvents = $atomicState.activeEvents | collectionSize = $events | timeout: $timeOut minutes"    \n\n        result = events > 0 || atomicState.activeEvents > 0 \n    }\n\n    logwarn "motion test duration: ${(now() - start)} millis"\n    //return true\n    return result\n}\ndef getTimeout(){\n    def result = noMotionTime // default\n    def valMode = location.mode\n\n    if(modetimeout && location.mode in timeoutModes)\n    {\n        int s = timeoutModes.size()\n        int i = 0\n        logging("timeoutModes: $timeoutModes")\n        while(i < s && location.mode != timeoutModes[i]){i++}\n        logging("${location.mode} == ${timeoutModes[i]} (timeoutModes${i} : index $i) ?: ${location.mode == timeoutModes[i]}")\n        valMode = "timeoutValMode${i}" // get the key as string to search its corresponding value within settings\n        logging("valMode = $valMode")\n        result = settings.find{it.key == valMode}?.value\n        logging("valMode.value == $result")\n    }\n    if(result == null)\n    {\n        result = noMotionTime\n    }\n    logging("timeout is: $result  ${if(modetimeout){"because home is in $location.mode mode"}}")\n\n\n    return result\n}\ndef resetMotionEvents(){\n    logging("No motion event has occured during the past $noMotionTime minutes")\n    atomicState.motionEvents = 0   \n}\ndef logging(msg){\n    //def debug = settings.find{it.key == "enablelogging"}?.value\n    //log.warn "debug = $debug"\n    if (enablelogging) log.debug msg\n}\ndef descriptiontext(msg){\n    //def debug = settings.find{it.key == "enablelogging"}?.value\n    //log.warn "debug = $debug"\n    if (enabledescription) log.info msg\n}\ndef logwarn(msg){\n    if(enablewarning) log.warn msg\n    if(enablewarning && now() - atomicState.enableWarning > 30 * 60 * 1000)\n    {\n        disablelogging()\n    }\n}\ndef disablelogging(){\n\n    app.updateSetting("enablelogging",[value:"false",type:"bool"])\n    app.updateSetting("enablewarning",[value:"false",type:"bool"])\n    log.debug "logging disabled!"\n}\ndef poll(){\n    logging "polling devices"\n    boolean haspoll = false\n    boolean hasrefresh = false\n    dimmers.each{\n        if(it.hasCommand("poll")){ it.poll() }else{logging("$it doesn\'t have poll command")}\n        if(it.hasCommand("refresh")){ it.refresh() }else{logging("$it doesn\'t have refresh command")}\n    }\n}\ndef formatText(title, textColor, bckgColor){\n    return  "<div style=\\"width:102%;background-color:${bckgColor};color:${textColor};padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\\">${title}</div>"\n}\n\ndef donate(){\n    def a = """\n<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">\n<input type="hidden" name="cmd" value="_s-xclick" />\n<input type="hidden" name="hosted_button_id" value="6JJV76SQGDVD6" />\n<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />\n<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" />\n</form>\n\n"""\n    return a\n}'
